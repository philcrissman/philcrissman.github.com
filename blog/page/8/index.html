
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>philcrissman.com</title>
	<meta name="author" content="Phil Crissman">

	
	<meta name="description" content="The second chapter of Introduction To Algorithms by Cormen, Leiserson, et al., describes the algorithms for Insertion Sort and Merge Sort in &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="philcrissman.com" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>

<body>
	<header id="header" class="inner"><h1><a href="/">philcrissman.com</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/about">About</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:philcrissman.com">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
    
		<a class="appdotnet" href="http://alpha.app.net/philcrissman" title="App.net">App.net</a>
    
		
		
		<a class="google" href="https://plus.google.com/115225600632800161143?rel=author" title="Google+">Google+</a>
		
		
		<a class="twitter" href="http://twitter.com/philcrissman" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/philcrissman" title="GitHub">GitHub</a>
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:philcrissman.com">
	</form>
</nav>

</header>
	
		<!-- ad -->
<div class="inner" style="text-align: center;border-top: 1px solid white; border-bottom: 1px solid #ddd;">
  <script type="text/javascript"><!--
    google_ad_client = "ca-pub-6000752616661499";
    /* testad */
    google_ad_slot = "1490708058";
    google_ad_width = 320;
    google_ad_height = 50;
    //-->
  </script>
  <script type="text/javascript"
    src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
  </script>
</div>

<!-- <div id="banner" class="inner"> -->
	<!-- <div class="container"> -->
	<!-- 	<ul class="feed"></ul> -->
	<!-- </div> -->
	<!-- <small><a href="http://twitter.com/philcrissman">philcrissman</a> @ <a href="http://twitter.com">Twitter</a></small> -->
	<!-- <div class="loading">Loading...</div> -->
<!-- </div> -->
<!-- <script src="/javascripts/twitter.js"></script> -->
<!-- <script type="text/javascript"> -->
<!-- 	(function($){ -->
<!-- 		$('#banner').getTwitterFeed('philcrissman', 4, false); -->
<!-- 	})(jQuery); -->
<!-- </script> -->


	
	<div id="content" class="inner">


    <article class="post">
	<h1 class="title"><a href="/2010/07/18/how-not-to-write-sorting-algorithms-in-ruby/">How Not to Write Sorting Algorithms in Ruby</a></h1>
	<div class="entry-content">
		<p>The second chapter of <a href="http://www.amazon.com/gp/product/0262033844?ie=UTF8&amp;tag=idepermin-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0262033844"><em>Introduction To Algorithms</em></a> by Cormen, Leiserson, et al., describes the algorithms for Insertion Sort and Merge Sort in pseudocode, and compares their relative efficiency (or lack thereof). I decided to write them out in Ruby and run some simple benchmarks, just for fun.</p>

<h2>Insertion Sort</h2>


<p>There are a variety of ways one could write the insertion sort in Ruby; this is more or less an literal translation of the <em>Intro to Algorithms</em> pseudocode to ruby &#8211; it could perhaps be made a little more ruby-ish, but here&#8217;s my version:</p>

<pre>
<code class="ruby">
def insertion_sort(sequence)
  sequence[1..sequence.size].each_with_index do |j, index|
    i = index
    sequence[0..i].reverse.each do |k|
      break unless k > j
      sequence[i + 1] = k
      i = i - 1
    end
    sequence[i+1] = j
  end
end
</code>
</pre>


<p>In a nutshell:</p>

<ol>
<li>Start with the second element (index 1).</li>
<li>Save the index in a local variable, because we&#8217;re going to use it to figure out which array element to swap the current element into.</li>
<li>Take the sub-array 0..i (where <em>i</em> is the current index being looked at), and go backwards until the element in your inner loop is less than the current element from the outer loop, also decrementing <em>i</em> each iteration.</li>
<li>Copy the element in index [i] to index [i + 1]</li>
<li>Outside the inner loop, we&#8217;ll put the current element at [i + 1].</li>
</ol>


<p>In case this is a little unclear, it would go something like this:</p>

<p>Starting array: [5,2,3,1,4,0]</p>

<p>First pass: [<strong>2</strong>,<em>5</em>,3,1,4,0]</p>

<p>Second pass: [2,<strong>3</strong>,<em>5</em>,1,4,0]</p>

<p>Third pass: [<strong>1</strong>,<em>2</em>,<em>3</em>,<em>5</em>,4,0]</p>

<p>Fourth pass: [1,2,3,<strong>4</strong>,<em>5</em>,0]</p>

<p>Fifth pass: [<strong>0</strong>,<em>1</em>,<em>2</em>,<em>3</em>,<em>4</em>,<em>5</em>]</p>

<p>(<strong>Bold elements</strong> are the ones which were the &#8220;current&#8221; element moved back, <em>italic elements</em> are the ones that had to be shifted forward in this step.)</p>

<h2>Merge Sort</h2>


<p>The merge sort is split into two parts; a <code>merge</code> method that acts as a helper, and the actual <code>merge_sort</code> which calls itself recursively, also calling <code>merge</code> when needed.</p>

<p>Here&#8217;s a version modeled after the pseudocode in <em>Intro to Algorithms</em>:</p>

<pre>
<code class="ruby">
def merge_sort(sequence, first, last)
  if first < last
    mid = (first + last) / 2
    merge_sort(sequence, first, mid)
    merge_sort(sequence, mid + 1, last)
    merge(sequence, first, mid + 1, last)
  end
end

def merge(sequence, first, mid, last)
  left = sequence[first..mid - 1]
  right = sequence[mid..last]
  left.push(Float::MAX)
  right.push(Float::MAX)
  i = 0
  j = 0
  (first..last).each do |n|
    if left[i] <= right[j]
      sequence[n] = left[i]
      i = i + 1
    else
      sequence[n] = right[j]
      j = j + 1
    end
  end
end
</code>
</pre>


<p>A few notes: You&#8217;ll notice that in the <code>merge</code> method, when the sequence is split into two parts, the value Float::MAX is pushed onto each as the final element. <em>Intro to Algorithms</em> uses the idea that &#8220;infinity&#8221; is set to the last element. Hopefully I can explain why in the description of the algorithm.</p>

<p>First, the merge method. The merge method assumes that the left half and the right half of the section of the array it&#8217;s looking at are <em>already sorted</em>. Having made this assumption, it loops through the range it&#8217;s considering (<code>first..last</code>), and puts either the first element of the left side, or the first element of the right side, whichever it least. It increments each subarray as it goes; when it gets past the last element of either array, Float::MAX will <em>always</em> be higher (or so we assume, for the sake of this implementation) than whatever is in the other array. So merge finishes up, basically (ahem) <em>merging</em> the two halves together in place, with the whole first..last range sorted.</p>

<p>Now, the actual merge_sort method. It first checks to see if first &lt; last; if this were <em>false</em>, then the range would be an array of size 1, and an array of size 1 is already sorted. So assuming the range first..last is > 1, it calculates a midpoint; integer division works fine for this, using <code>(first + last) / 2</code>. Then it calls itself recursively on each subarray; these in turn will continue splitting each subarray into two parts until it gets to the point where it&#8217;s just two subarrays of one element each; which are then fed to <code>merge</code> and sorted. As the method returns from each level of recursion, each &#8220;half&#8221; of the subarray under consideration has been sorted, until it gets all the way back to the first call to <code>merge_sort</code>, and executes <code>merge</code> on each (sorted) half of the full array.</p>

<p>Phew. I&#8217;m going to attempt to show another example, in case that&#8217;s helpful. Let&#8217;s say we started with the same starting array as the insertion_sort example. This time, to show what the recursion is actually doing, I&#8217;ll write out what each nested call to merge_sort( and/or merge) would actually look like:</p>

<p>Starting array: [5,2,3,1,4,0]</p>

<pre style="font-size:0.8em !important;">
merge_sort([5,2,3,1,4,0], 0, 5):
  mid <- 2
  merge_sort([5,2,3], 0, 2):
    mid <- 1
    merge_sort([5,2], 0, 1):
      mid <- 0
      merge_sort([5], 0, 0):
      merge_sort([2], 1, 1):
      merge([5,2],0, 1, 1):
        left <- [5,&infin;]
        right <- [2,&infin;]
        loop(0..1):
          [2,5] # just showing the result in this step; the two elements are sorted.
    merge_sort([3], 2, 2):
    merge([2,5,3], 0, 2, 2):
      left <- [2,5,&infin;]
      right <- [3,&infin;]
      loop(0..2):
        [2,3,5]
  merge_sort([1,4,0], 3, 5):
    mid <- 4
    merge_sort([1,4], 3, 4):
      mid <- 3
      merge_sort([1], 3, 3):
      merge_sort([4], 4, 4):
      merge([1,4], 3, 4, 4):
        left <- [1,&infin;]
        right <- [4,&infin;]
        loop(3..4):
          [1,4]
    merge_sort([0], 5, 5):
    merge([1,4,0], 3, 5, 5):
      left <- [1,4,&infin;]
      right <- [0,&infin;]
      loop(3..5):
        [0,1,4]
  merge([2,3,5,0,1,4], 0, 3, 5):
    left <- [2,3,5,&infin;]
    right <- [0,1,4,&infin;]
    loop(0..5):
      [0,1,2,3,4,5]
</pre>


<p>Uhm, hopefully that&#8217;s clear. If you&#8217;re bothering to read this and it still isn&#8217;t clear, just run the sort locally and add some <code>print</code> or <code>puts</code> statements liberally so you can see what&#8217;s going on. Note: I did take a liberty in the above listing of what&#8217;s happening; in actuality the entire array is passed each time; I made it look as though just the subarray were being passed in each case, because that is the only part that is being looked at in each nested section. Again, if you&#8217;re interested enough in the topic that you&#8217;re still working out this algorithm, fire up irb and just try it out, it will make more sense as you do so.</p>

<h2>Wait, why is this called &#8220;how <em>not</em> to write sorting algorithms&#8230;?&#8221;</h2>


<p>Aha. I thought you&#8217;d never ask. Well, the main reason is that both of these methods are significantly slower than good old Array::sort, which is built in to Ruby (and which, as far as I know, is implemented using the <a href="http://en.wikipedia.org/wiki/Quicksort">quicksort</a> algorithm).</p>

<p>So, just for fun, I wrote a little script to make some benchmarks of these various methods on arrays of various sizes. Here were the results:</p>

<pre style="font-size:0.8em !important;">
      user     system      total        real

 small_array has 100 elements in it...
Insertion Sort (small_array): 
  0.000000   0.000000   0.000000 (  0.002122)
Merge sort (small_array): 
  0.000000   0.000000   0.000000 (  0.001499)
Ruby Array::sort (small_array): 
  0.000000   0.000000   0.000000 (  0.000016)

 bigger_array has 1000 elements in it...
Insertion sort (bigger_array): 
  0.240000   0.000000   0.240000 (  0.238994)
Merge sort (bigger array): 
  0.030000   0.010000   0.040000 (  0.027746)
Ruby Array::sort (bigger_array): 
  0.000000   0.000000   0.000000 (  0.000161)

 medium_array has 10,000 elements in it...
Insertion sort (medium_array): 
 23.960000   0.010000  23.970000 ( 24.096455)
Merge sort (medium_array): 
  0.720000   0.020000   0.740000 (  0.726312)
Ruby Array::sort (medium_array): 
  0.000000   0.000000   0.000000 (  0.001637)

 huge_array has 100,000 elements in it...
Sorry, the insertion_sort was taking too long! Skipped it.
Merge sort (huge_array): 
 61.710000  11.990000  73.700000 ( 74.332743)
ruby Array::sort (huge_array): 
  0.020000   0.000000   0.020000 (  0.020800)


</pre>


<p>The interesting column is the last one: <em>real</em>, as in &#8220;real time&#8221; (more or less, taking into the account that we&#8217;re just benchmarking).</p>

<p>The small array is pretty fast for all three methods, but even still, we can see that merge_sort is a <em>little</em> faster, and the built in .sort! (using quicksort) is <em>way</em> faster: only 0.000016 seconds.</p>

<p>The next bigger, bigger_array, the differences stand out a little more. Insertion takes 0.24 seconds, merge takes 0.028, and sort! (again), way faster, only 0.00016 seconds.</p>

<p>A ten thousand element array starts to show the difference even more dramatically: insertion_sort now takes 24.1 seconds, close to half a minute, while the merge_sort still runs in under a second. sort!, once again, is blowing them away at only 0.0016 seconds.</p>

<p>Finally, a hundred thousand element array; sorry for the lack of stats, but I was too impatient to let insertion_sort finish. Let&#8217;s just say it would take awhile. Now even the merge_sort shows its limits, taking over a minute, about 74.3 seconds. And finally, good old sort! clocking in at only 0.02 seconds.</p>

<p>So the reason this is how <em>not</em> to write sorting algorithms in ruby is simply that, you really probably don&#8217;t need to, unless you need something faster than a quicksort written in C. The reason, hopefully, to be playing around writing algorithms in Ruby or in <em>whatever</em> your favorite language happens to be, is just to understand them better.</p>

<p>And it&#8217;s fun.</p>

<p>See also:</p>

<p><a href="http://en.wikipedia.org/wiki/Insertion_sort">Insertion Sort</a></p>

<p><a href="http://en.wikipedia.org/wiki/Merge_sort">Merge Sort</a></p>

<p><a href="http://github.com/kanwei/algorithms">Ruby Algorithm library</a> &lt;&#8211; some pretty interesting stuff in here. I didn&#8217;t look at this until after I&#8217;d already written my versions of the insertion sort and the merge sort; their version of insertion_sort is nearly the same, but their merge sort is somewhat more succinct, and looks worth playing around with.)</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2010-07-18T00:00:00-05:00" pubdate data-updated="true">Jul 18<span>th</span>, 2010</time></div>
	<div class="tags">

</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/2010/07/08/relative-primes-revisited/">Relative Primes, Revisited</a></h1>
	<div class="entry-content">
		<p>As I thought; there&#8217;s always a better way to do it. <a href="http://twitter.com/jmchilton">@jmchilton</a>, who was a TA when I took Structure of Computer Programming I (or whatever it was called; the Scheme class) at the U of M, supplied this alternative solution to the relative prime problem:</p>

<pre>
<code class="ruby">
def gcd(a, b); b == 0 ? a : gcd(b, a % b); end; def rp(a, b); gcd(a, b) == 1; end
</code>
</pre>


<p>Or, indented:</p>

<pre>
<code class="ruby">
def gcd(a, b)
  b == 0 ? a : gcd(b, a % b)
end

def rp(a, b)
  gcd(a, b) == 1
end
</code>
</pre>


<p>In other words, it pays to know your math. <code>gcd</code> is a recursive function, basically Euclid&#8217;s algorithm for finding the greatest common denominator. <code>rp</code>, then, simply returns true if the GCD of a and b is 1; otherwise false.</p>

<p>Very nice. I wish I&#8217;d thought to do it that way, but I&#8217;ll certainly remember it.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2010-07-08T00:00:00-05:00" pubdate data-updated="true">Jul 8<span>th</span>, 2010</time></div>
	<div class="tags">

</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/2010/07/07/relative-primes/">Relative Primes</a></h1>
	<div class="entry-content">
		<p>I didn&#8217;t expect to do a &#8220;code kata&#8221;-type post again so quickly, but here it is anyways.</p>

<p>I was reading Randall Hyde&#8217;s excellent <a href="http://www.amazon.com/gp/product/1593270038?ie=UTF8&amp;tag=idepermin-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1593270038">Writing Great Code: Volume 1</a> and came across the concept of relative primes.</p>

<p>If you haven&#8217;t heard the term in awhile, relative primes are simply two numbers that are not both evenly divisible by the same value (not counting 1, of course).</p>

<p>Writing some code to determine if two integers are relatively prime seemed interesting, so I gave it a first shot:</p>

<figure class='code'><figcaption><span>relprime.rb </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='rb'><span class='line'><span class="c1"># relprime01.rb</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">rel_prime</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</span><span class='line'>  <span class="c1"># if either number is one, they are automatically relatively prime.</span>
</span><span class='line'>  <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># determine a&#39;s factors.</span>
</span><span class='line'>  <span class="n">fa</span> <span class="o">=</span> <span class="n">factors</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'>  <span class="c1"># determine b&#39;s factors.</span>
</span><span class='line'>  <span class="n">fb</span> <span class="o">=</span> <span class="n">factors</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># are any factors the same? then false</span>
</span><span class='line'>  <span class="c1"># if no factors are shared, then true.</span>
</span><span class='line'>  <span class="c1"># ie, if the intersect is empty, true, else false.</span>
</span><span class='line'>  <span class="p">(</span><span class="n">fa</span> <span class="o">&amp;</span> <span class="n">fb</span><span class="p">)</span><span class="o">.</span><span class="n">empty?</span>
</span><span class='line'>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">factors</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">a</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">1</span>
</span><span class='line'>  <span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.a</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="o">|</span> <span class="n">k</span> <span class="k">if</span> <span class="n">a</span><span class="o">%</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span> <span class="p">}</span><span class="o">.</span><span class="n">compact</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>So, open up irb, <code>require 'rel_prime01.rb'</code>, and you have a method for determining if 2 integers are relatively prime. It has some issues, and would not be very efficient for large values. Before addressing that, I thought I&#8217;d just go straight to monkeypatching <code>Integer</code> again.</p>

<p>Note: there&#8217;s another problem with the above method, too. See it? See below the next listing for what it is.</p>

<figure class='code'><figcaption><span>relprime02.rb </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='rb'><span class='line'><span class="c1"># rel_prime02.rb</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Integer</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># usage: x.rel_prime?(y)</span>
</span><span class='line'>  <span class="c1"># returns true if x and y are relatively prime.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">rel_prime?</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">abs</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">n</span><span class="o">.</span><span class="n">abs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1"># All number pairs have 1 as a shared factor; it doesn&#39;t count. So we subtract it from the array before checking [ ].empty?</span>
</span><span class='line'>    <span class="p">((</span><span class="nb">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span> <span class="o">-</span> <span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">empty?</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># usage: x.factors</span>
</span><span class='line'>  <span class="c1"># returns an array of the factors of x</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">factors</span>
</span><span class='line'>    <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.self</span><span class="o">.</span><span class="n">abs</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="o">|</span> <span class="n">k</span> <span class="k">if</span> <span class="nb">self</span><span class="o">.</span><span class="n">abs</span><span class="o">%</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span> <span class="p">}</span><span class="o">.</span><span class="n">compact</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Essentially the same algorithm; if either integer is 1, then the numbers are automatically relative primes; 1 has no factors other than itself, so the only factor they share is 1. If both numbers are not 1, it gets the full list of factors of both numbers, checks to see if they have any in common, returns false if they do, and true if they don&#8217;t.</p>

<p>The problem fixed in the second code is the use of Integer::abs in the appropriate places; that first code listing would blow up if you supplied a negative integer. Negative integers should be allowed, so this code uses .abs to make everything work properly, as it should.</p>

<p>There&#8217;s still a big problem for checking large numbers. Each time we check relative primes, we&#8217;re getting ALL the factors of each integer, and then comparing them when we&#8217;re done. That could take a really long time, and the code above iterates though every single value from <code>1..x</code> for each <code>x</code> we give it&#8230; even if that number turns out to be (gasp!) prime. This won&#8217;t do at all. It will give us correct answers, but it will take a really long time to do it if we supply large values.</p>

<p>How could we improve it? Well, one way would be to check common factors as we go. That way, if both numbers are even, we find out they share a factor on the very first iteration, and we simply stop: they are not relatively prime. Here&#8217;s this one:</p>

<figure class='code'><figcaption><span>rel_prime03.rb </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='rb'><span class='line'><span class="c1"># rel_prime03.rb</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Integer</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># usage: x.rel_prime?(y)</span>
</span><span class='line'>  <span class="c1"># returns true if x and y are relatively prime.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">rel_prime?</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">abs</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">n</span><span class="o">.</span><span class="n">abs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1"># different approach; go through (1..min(self,n).abs), </span>
</span><span class='line'>    <span class="c1"># build an array for each number&#39;s factors as we go.</span>
</span><span class='line'>    <span class="c1"># each time you add a factor, check if the two arrays share it.</span>
</span><span class='line'>    <span class="c1"># if they do, end right away with false; </span>
</span><span class='line'>    <span class="c1"># else, keep searching for common factors.</span>
</span><span class='line'>    <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=[]</span><span class="p">,</span><span class="o">[]</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="n">.</span><span class="o">[</span><span class="nb">self</span><span class="p">,</span><span class="n">n</span><span class="o">].</span><span class="n">sort</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">abs</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="o">|</span>
</span><span class='line'>      <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="k">if</span> <span class="nb">self</span> <span class="o">%</span> <span class="n">k</span>  <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>      <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">k</span>     <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>      <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">empty?</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1"># if you get here, it&#39;s because you found no common factors. return true.</span>
</span><span class='line'>    <span class="kp">true</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>So, this time we make 2 empty arrays, x and y. Each time we find a factor of self or n we add it to either x or y and then check if the intersection of those two arrays (using &amp;) is empty; if it&#8217;s ever not empty, return false right away and stop checking. If we get all the way to the end without finding a common factor, we can return true.</p>

<p>This is better; works great for large numbers IFF the common factor is a fairly low number. But what if it isn&#8217;t? What if the common factor is a 7 digit long prime number?</p>

<p>We know that there will be cases &#8230; large primes, for example &#8230; where we do basically need to check all the way up till we reach the last value that could be possible (the lesser of self and n, whichever that happens to be). But there&#8217;s a lot of number in-between that we don&#8217;t need to check. For example, if 2 is not a common factor, then we never need to check multiples of 2 again. If 3 is not a common factor, we never need to check multiples of 3 again. And so on. So really, if x is the lesser of self and n, the range we need to check will look something like:</p>

<p><code>[2,3,5,7,11,13 ... x]</code></p>

<p>Hm. That list looks familiar. Basically, we only need to check to see if prime numbers are factors of self and n; if a given prime number is not a factor, neither will any of its multiples be a factor.</p>

<p>Generating a list of primes wasn&#8217;t on the to-do list, but fortunately ruby has a class in mathn called Prime, which returns an enumerator for iterating over the prime numbers. How convenient!</p>

<figure class='code'><figcaption><span>rel_prime04.rb </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='rb'><span class='line'><span class="c1"># rel_prime04.rb</span>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;mathn&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Integer</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># usage: x.rel_prime?(y)</span>
</span><span class='line'>  <span class="c1"># returns true if x and y are relatively prime.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">rel_prime?</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">abs</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">n</span><span class="o">.</span><span class="n">abs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1"># one more quick check; does self % n == 0?</span>
</span><span class='line'>    <span class="c1"># if it does, we save some time; we know right away they aren&#39;t relatively prime,</span>
</span><span class='line'>    <span class="c1"># and we don&#39;t need to iterate all the way up before we find out.</span>
</span><span class='line'>    <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="nb">self</span> <span class="o">%</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=[]</span><span class="p">,</span><span class="o">[]</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1"># Prime.instance gives us an enumerator over the Prime numbers.</span>
</span><span class='line'>    <span class="c1"># Enumerating over only primes saves us the wasted effort </span>
</span><span class='line'>    <span class="c1"># of rechecking multiples of factors we&#39;ve already ruled out.</span>
</span><span class='line'>    <span class="c1"># etc.</span>
</span><span class='line'>    <span class="nb">p</span> <span class="o">=</span> <span class="no">Prime</span><span class="o">.</span><span class="n">instance</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">p</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="o">|</span>
</span><span class='line'>      <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="k">if</span> <span class="nb">self</span> <span class="o">%</span> <span class="n">k</span>  <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>      <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">k</span>     <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>      <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">empty?</span>
</span><span class='line'>      <span class="k">break</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="o">[</span><span class="nb">self</span><span class="p">,</span><span class="n">n</span><span class="o">].</span><span class="n">sort</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">abs</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1"># if you get here, it&#39;s because you found no common factors. return true.</span>
</span><span class='line'>    <span class="kp">true</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, the above code uses Prime::instance to create the enumerator, which is a ruby 1.9 thing; you can do this in ruby 1.8.x, but you&#8217;ll need <code>Prime.new</code> instead of <code>Prime.instance</code>. Warning, though, I found that the Prime enumerator in 1.8.x was still pretty slow for larger integers. The 1.9 version is <em>very</em> fast. For easy ways to get ruby 1.9.x installed without messing too much with your existing environment, check out <a href="http://rvm.beginrescueend.com/">rvm</a>.</p>

<p>So now we&#8217;re doing essentially the same as the rel_prime03.rb version, but we&#8217;re skipping the multiples of any factors we&#8217;ve already ruled out by <em>only</em> iterating through the prime numbers. In the loop, you&#8217;ll see we stop if <code>k >= [self,n].sort[0]</code>, which is the lesser of self and n (I felt like there might be a more elegant way to quickly find the lesser of two integers, but I didn&#8217;t look; anyone?).</p>

<p>One more thing was added, here: right at the beginning, after checking if self or n (abs) is equal to 1, we also check if self % n == 0. If it does, we just saved some time; see the comments in the listing above.</p>

<p>That&#8217;s that, then. A method added to Integer that checks if two integers are relatively prime.</p>

<p>Is there a better way to do it? I&#8217;m fairly certain there is (there usually is), so if you know of one, feel free to leave a note or a link in the comments.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2010-07-07T00:00:00-05:00" pubdate data-updated="true">Jul 7<span>th</span>, 2010</time></div>
	<div class="tags">

</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/2010/07/06/various-fizzbuzzes/">Various Fizzbuzzes</a></h1>
	<div class="entry-content">
		<p>Every so often I remember reading posts like <a href="http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html">Why can&#8217;t programmers&#8230; program?</a>, or <a href="http://reprog.wordpress.com/2010/04/19/are-you-one-of-the-10-percent/">Are you one of the 10% of programmers who can implement a binary search?</a>, or even various things about the idea of <a href="http://duckduckgo.com/?q=code+kata&amp;v=">code kata</a>, and that makes me want to just spend a little time practicing, rather than just working. Very often while working, we&#8217;re resolving a problem we (and/or others) have solve dozens of times before, and it&#8217;s really not very challenging or stretching.</p>

<p>Since I was thinking about it, I decided to just start with the FizzBuzz example, from <a href="http://weblog.raganwald.com/2007/01/dont-overthink-fizzbuzz.html">Reginald Braithwaite</a> via Jeff Atwood.</p>

<p>First solution:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">print</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s2">&quot;Fizz&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span>
</span><span class='line'>  <span class="nb">print</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s2">&quot;Buzz&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span>
</span><span class='line'>  <span class="nb">print</span> <span class="n">k</span> <span class="k">unless</span> <span class="p">(</span><span class="n">k</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">print</span> <span class="s2">&quot; &quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>So, that&#8217;s simple enough. I thought maybe it could be a little more compact, but essentially unchanged, here was the next version:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">print</span> <span class="n">k</span><span class="o">%</span><span class="mi">3</span><span class="o">==</span><span class="mi">0</span> <span class="o">?</span> <span class="s2">&quot;Fizz&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">k</span><span class="o">%</span><span class="mi">5</span><span class="o">==</span><span class="mi">0</span> <span class="o">?</span> <span class="s2">&quot;Buzz&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="o">%</span><span class="mi">3</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="n">k</span><span class="o">%</span><span class="mi">5</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">?</span> <span class="s2">&quot;&quot;</span> <span class="p">:</span> <span class="n">k</span><span class="p">,</span>  <span class="s2">&quot; &quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&#8217;s nice and all, but I&#8217;m now trying to think if I can find other ways to do it. Preferably shorter and/or more elegant. Maybe. <code>003.rb</code> was next.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="o">|</span>
</span><span class='line'>  <span class="n">word</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span><span class='line'>  <span class="n">word</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Fizz&quot;</span> <span class="k">if</span> <span class="n">k</span><span class="o">%</span><span class="mi">3</span><span class="o">==</span><span class="mi">0</span>
</span><span class='line'>  <span class="n">word</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Buzz&quot;</span> <span class="k">if</span> <span class="n">k</span><span class="o">%</span><span class="mi">5</span><span class="o">==</span><span class="mi">0</span>
</span><span class='line'>  <span class="nb">print</span> <span class="n">word</span><span class="o">.</span><span class="n">empty?</span> <span class="p">?</span> <span class="n">k</span> <span class="p">:</span> <span class="n">word</span><span class="p">,</span> <span class="s2">&quot; &quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Not really shorter or elegant, but a slightly different approach, filling a placeholder variable with &#8220;Fizz&#8221;, &#8220;Buzz&#8221; (or both), and then deciding which one to display based on whether or not the placeholder was <code>empty?</code> (If you aren&#8217;t familiar with Ruby, <code>"".empty? == true &amp;&amp; "anything".empty? == false</code>.)</p>

<p>Again, I tried to pare that down a little.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="o">|</span> <span class="n">w</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">;</span><span class="n">w</span><span class="o">&lt;&lt;</span><span class="s2">&quot;Fizz&quot;</span><span class="k">if</span> <span class="n">k</span><span class="o">%</span><span class="mi">3</span><span class="o">==</span><span class="mi">0</span><span class="p">;</span><span class="n">w</span><span class="o">&lt;&lt;</span><span class="s2">&quot;Buzz&quot;</span><span class="k">if</span> <span class="n">k</span><span class="o">%</span><span class="mi">5</span><span class="o">==</span><span class="mi">0</span><span class="p">;</span><span class="n">w</span><span class="o">.</span><span class="n">empty?</span> <span class="p">?</span> <span class="n">k</span> <span class="p">:</span> <span class="n">w</span> <span class="p">}</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Well, I don&#8217;t know if it&#8217;s readable, or anything resembling elegant, but it&#8217;s, um&#8230; more compact.</p>

<p>At that point I glanced back at my first solution, and something was bugging me about it; oh, yeah. The ternary expressions that returned &#8220;&#8221; for the false case. That seemed unnecessary. 005.rb tries to fix it.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">print</span> <span class="s2">&quot;Fizz&quot;</span> <span class="k">if</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>  <span class="nb">print</span> <span class="s2">&quot;Buzz&quot;</span> <span class="k">if</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>  <span class="nb">print</span> <span class="n">k</span> <span class="k">unless</span> <span class="p">(</span><span class="n">k</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">print</span> <span class="s2">&quot; &quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Essentially unchanged. I&#8217;m not even sure it&#8217;s any more efficient but it <em>feels</em> less like there&#8217;s wasted code in there, so I like it a little better. Now, it&#8217;s not really <em>changing</em> much, but what if we extract the logic into it&#8217;s own method?</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</span><span class='line'>  <span class="n">w</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span><span class='line'>  <span class="n">w</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Fizz&quot;</span> <span class="k">if</span> <span class="n">k</span><span class="o">%</span><span class="mi">3</span><span class="o">==</span><span class="mi">0</span>
</span><span class='line'>  <span class="n">w</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Buzz&quot;</span> <span class="k">if</span> <span class="n">k</span><span class="o">%</span><span class="mi">5</span><span class="o">==</span><span class="mi">0</span>
</span><span class='line'>  <span class="n">w</span><span class="o">.</span><span class="n">empty?</span> <span class="p">?</span> <span class="n">k</span> <span class="p">:</span> <span class="n">w</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="o">|</span> <span class="nb">print</span> <span class="n">fizzbuzz</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="s2">&quot; &quot;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Hey, that&#8217;s&#8230; well, it&#8217;s essentially the same, but the lesser rites of refactoring have been appeased by pulling that code into it&#8217;s own little method.</p>

<p>Hey. That makes me think we could just:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Integer</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">fizzbuzz</span>
</span><span class='line'>    <span class="n">w</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="nb">self</span><span class="o">%</span><span class="mi">3</span><span class="o">==</span><span class="mi">0</span> <span class="o">?</span> <span class="s2">&quot;Fizz&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="nb">self</span><span class="o">%</span><span class="mi">5</span><span class="o">==</span><span class="mi">0</span> <span class="o">?</span> <span class="s2">&quot;Buzz&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">w</span><span class="o">.</span><span class="n">empty?</span> <span class="p">?</span> <span class="nb">self</span> <span class="p">:</span> <span class="n">w</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="o">|</span> <span class="n">k</span><span class="o">.</span><span class="n">fizzbuzz</span> <span class="p">}</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>So, a couple different things here. We open up <code>Integer</code> and add a fizzbuzz method to it. The idea of a place holder with either &#8220;Fizz&#8221;, &#8220;Buzz&#8221;, or both added to it is streamlined slightly by adding the concatenation lines right into the variable assignment. To make that work, we have to go back to using the ternary operator (can you see why? If we just did <code>w &lt;&lt; "Fizz" if k%3==0</code>, it would try to append <code>nil</code> to the String, and you&#8217;d get a horrible &#8220;Unable to convert nil to String&#8221; error anytime a non-multiple of 3 or 5 came up).</p>

<p>So, that&#8217;s that. I know this is simple, maybe trivial, but hey, who wants to be the guy who couldn&#8217;t program a FizzBuzz solution in the interview?</p>

<p>This was a fun exercise, so I&#8217;ll probably try to do some more like it. I&#8217;ll likely start by mining Code Kata, implementing some algorithms, or something. Feel free to leave problem suggestions in the comments.</p>

<p>Thanks!</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2010-07-06T00:00:00-05:00" pubdate data-updated="true">Jul 6<span>th</span>, 2010</time></div>
	<div class="tags">

</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/2010/06/28/introducing-henry-a-theme-for-toto/">Introducing Henry, a Theme for Toto</a></h1>
	<div class="entry-content">
		<p>As a response to no demand whatsoever, I nevertheless extracted my theme for this blog into it&#8217;s own standalone theme for <a href="http://cloudhead.io/toto">toto</a> that you could use just like <a href="http://github.com/cloudhead/dorothy">dorothy</a></p>

<p>Keeping with the Oz names, I called it <a href="http://github.com/philcrissman/henry">henry</a>.</p>

<p>Installation is pretty much identical as you would to for toto and dorothy:</p>

<pre>
<code class="bash">
gem install toto
git clone git://github.com/philcrissman/henry.git myblog
cd myblog
heroku create myblog
git push heroku master
</code>
</pre>


<p>Now, I pretty much completely disregarded IE support when I designed the blog, so as a result I don&#8217;t think henry will look like anything much in IE. You&#8217;re on your own. I will probably eventually feel like I should update this or address it somehow, but I&#8217;m not making any guarantees as to when that would be.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2010-06-28T00:00:00-05:00" pubdate data-updated="true">Jun 28<span>th</span>, 2010</time></div>
	<div class="tags">

</div>
	
</div></article>

<nav id="pagenavi">
    
        <a href="/blog/page/7/" class="prev">Prev</a>
    
    
        <a href="/blog/page/9/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2012

    Phil Crissman

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->




	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-77047-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


<div style="text-align: center">
  <script type="text/javascript"><!--
    google_ad_client = "ca-pub-6000752616661499";
    /* testad */
    google_ad_slot = "1490708058";
    google_ad_width = 320;
    google_ad_height = 50;
    //-->
  </script>
  <script type="text/javascript"
    src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
  </script>
</div>

</body>
</html>