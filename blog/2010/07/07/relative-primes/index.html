<p>I didn&#8217;t expect to do a &#8220;code kata&#8221;-type post again so quickly, but here it is anyways.</p>

<p>I was reading Randall Hyde&#8217;s excellent <a href="http://www.amazon.com/gp/product/1593270038?ie=UTF8&amp;tag=idepermin-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1593270038">Writing Great Code: Volume 1</a> and came across the concept of relative primes.</p>

<p>If you haven&#8217;t heard the term in awhile, relative primes are simply two numbers that are not both evenly divisible by the same value (not counting 1, of course).</p>

<p>Writing some code to determine if two integers are relatively prime seemed interesting, so I gave it a first shot:</p>

<pre>
<code class="ruby">
# relprime01.rb

def rel_prime(a, b)  
  # if either number is one, they are automatically relatively prime.
  return true if (a == 1 || b == 1)
  
  # determine a's factors.
  fa = factors(a)
  # determine b's factors.
  fb = factors(b)
  
  # are any factors the same? then false
  # if no factors are shared, then true.
  # ie, if the intersect is empty, true, else false.
  (fa & fb).empty?
  
end

def factors(a)
  return a if a == 1
  (2..a).map{|k| k if a%k==0 }.compact
end
</code>
</pre>


<p>So, open up irb, <code>require 'rel_prime01.rb'</code>, and you have a method for determining if 2 integers are relatively prime. It has some issues, and would not be very efficient for large values. Before addressing that, I thought I&#8217;d just go straight to monkeypatching <code>Integer</code> again.</p>

<p>Note: there&#8217;s another problem with the above method, too. See it? See below the next listing for what it is.</p>

<pre>
<code class="ruby">
# rel_prime02.rb

class Integer

  # usage: x.rel_prime?(y)
  # returns true if x and y are relatively prime.
  def rel_prime?(n)
    return true if (self.abs == 1 || n.abs == 1)
    
    # All number pairs have 1 as a shared factor; it doesn't count. So we subtract it from the array before checking [ ].empty?
    ((self.factors & n.factors) - [1]).empty?
  end

  # usage: x.factors
  # returns an array of the factors of x
  def factors
    (1..self.abs).map{|k| k if self.abs%k==0 }.compact
  end
end
</code>
</pre>


<p>Essentially the same algorithm; if either integer is 1, then the numbers are automatically relative primes; 1 has no factors other than itself, so the only factor they share is 1. If both numbers are not 1, it gets the full list of factors of both numbers, checks to see if they have any in common, returns false if they do, and true if they don&#8217;t.</p>

<p>The problem fixed in the second code is the use of Integer::abs in the appropriate places; that first code listing would blow up if you supplied a negative integer. Negative integers should be allowed, so this code uses .abs to make everything work properly, as it should.</p>

<p>There&#8217;s still a big problem for checking large numbers. Each time we check relative primes, we&#8217;re getting ALL the factors of each integer, and then comparing them when we&#8217;re done. That could take a really long time, and the code above iterates though every single value from <code>1..x</code> for each <code>x</code> we give it&#8230; even if that number turns out to be (gasp!) prime. This won&#8217;t do at all. It will give us correct answers, but it will take a really long time to do it if we supply large values.</p>

<p>How could we improve it? Well, one way would be to check common factors as we go. That way, if both numbers are even, we find out they share a factor on the very first iteration, and we simply stop: they are not relatively prime. Here&#8217;s this one:</p>

<pre>
<code class="ruby">
# rel_prime03.rb

class Integer

  # usage: x.rel_prime?(y)
  # returns true if x and y are relatively prime.
  def rel_prime?(n)
    return true if (self.abs == 1 || n.abs == 1)
    
    # different approach; go through (1..min(self,n).abs), 
    # build an array for each number's factors as we go.
    # each time you add a factor, check if the two arrays share it.
    # if they do, end right away with false; 
    # else, keep searching for common factors.
    x,y =[],[]
    
    
    (2..[self,n].sort[0].abs).each do |k|
      x << k if self % k  == 0
      y << k if n % k     == 0
      return false unless (x & y).empty?
    end
    
    # if you get here, it's because you found no common factors. return true.
    true
  end

end
</code>
</pre>


<p>So, this time we make 2 empty arrays, x and y. Each time we find a factor of self or n we add it to either x or y and then check if the intersection of those two arrays (using &amp;) is empty; if it&#8217;s ever not empty, return false right away and stop checking. If we get all the way to the end without finding a common factor, we can return true.</p>

<p>This is better; works great for large numbers IFF the common factor is a fairly low number. But what if it isn&#8217;t? What if the common factor is a 7 digit long prime number?</p>

<p>We know that there will be cases &#8230; large primes, for example &#8230; where we do basically need to check all the way up till we reach the last value that could be possible (the lesser of self and n, whichever that happens to be). But there&#8217;s a lot of number in-between that we don&#8217;t need to check. For example, if 2 is not a common factor, then we never need to check multiples of 2 again. If 3 is not a common factor, we never need to check multiples of 3 again. And so on. So really, if x is the lesser of self and n, the range we need to check will look something like:</p>

<p><code>[2,3,5,7,11,13 ... x]</code></p>

<p>Hm. That list looks familiar. Basically, we only need to check to see if prime numbers are factors of self and n; if a given prime number is not a factor, neither will any of its multiples be a factor.</p>

<p>Generating a list of primes wasn&#8217;t on the to-do list, but fortunately ruby has a class in mathn called Prime, which returns an enumerator for iterating over the prime numbers. How convenient!</p>

<pre>
<code class="ruby">
# rel_prime04.rb
require 'mathn'

class Integer

  # usage: x.rel_prime?(y)
  # returns true if x and y are relatively prime.
  def rel_prime?(n)
    return true if (self.abs == 1 || n.abs == 1)
    
    # one more quick check; does self % n == 0?
    # if it does, we save some time; we know right away they aren't relatively prime,
    # and we don't need to iterate all the way up before we find out.
    return true if self % n == 0
    
    x,y =[],[]
    
    # Prime.instance gives us an enumerator over the Prime numbers.
    # Enumerating over only primes saves us the wasted effort 
    # of rechecking multiples of factors we've already ruled out.
    # etc.
    p = Prime.instance
    
    p.each do |k|
      x << k if self % k  == 0
      y << k if n % k     == 0
      return false unless (x & y).empty?
      break if k >= [self,n].sort[0].abs
    end
    
    # if you get here, it's because you found no common factors. return true.
    true
  end
end
</code>
</pre>


<p>Now, the above code uses Prime::instance to create the enumerator, which is a ruby 1.9 thing; you can do this in ruby 1.8.x, but you&#8217;ll need <code>Prime.new</code> instead of <code>Prime.instance</code>. Warning, though, I found that the Prime enumerator in 1.8.x was still pretty slow for larger integers. The 1.9 version is <em>very</em> fast. For easy ways to get ruby 1.9.x installed without messing too much with your existing environment, check out <a href="http://rvm.beginrescueend.com/">rvm</a>.</p>

<p>So now we&#8217;re doing essentially the same as the rel_prime03.rb version, but we&#8217;re skipping the multiples of any factors we&#8217;ve already ruled out by <em>only</em> iterating through the prime numbers. In the loop, you&#8217;ll see we stop if <code>k >= [self,n].sort[0]</code>, which is the lesser of self and n (I felt like there might be a more elegant way to quickly find the lesser of two integers, but I didn&#8217;t look; anyone?).</p>

<p>One more thing was added, here: right at the beginning, after checking if self or n (abs) is equal to 1, we also check if self % n == 0. If it does, we just saved some time; see the comments in the listing above.</p>

<p>That&#8217;s that, then. A method added to Integer that checks if two integers are relatively prime.</p>

<p>Is there a better way to do it? I&#8217;m fairly certain there is (there usually is), so if you know of one, feel free to leave a note or a link in the comments.</p>
