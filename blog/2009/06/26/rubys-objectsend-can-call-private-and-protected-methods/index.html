<hr />

<p>title: Ruby&#8217;s Object#send Can Call Private And Protected Methods
date: 26/06/2009</p>

<p><a href="http://www.flickr.com/photos/xiaming/99206245/"><img src="http://farm1.static.flickr.com/30/99206245_862bc5c93d.jpg?v=0" /></a>
<small>Photo by <a href="http://www.flickr.com/photos/xiaming/99206245/">xiaming</a></small></p>

<p>One of the hallmarks of object oriented programming in most every implementation of it that I know of is the ability to designate certain methods as &#8220;private&#8221; or &#8220;protected&#8221;, thus keeping them from being called willy-nilly by any old script that wants to call them. Ruby also has this, of course, but interestingly enough it can be easily circumvented.</p>

<p>I guess there are a few posts floating around about it, but I discovered it by accident playing around in irb this evening. I was reading David A. Black&#8217;s The Well Grounded Rubyist, where he mentions that you could send a message to a class either within the class definition itself, or by simply sending it to the class object like you&#8217;d send any other message:</p>

<pre>
<code class="ruby">
# The normal way to do it
class Thing
  message :whatever
end

# you could also do this
Thing.message(:whatever)
</code>
</pre>


<p>David mention&#8217;s attr_accessor in this context, so I thought I&#8217;d try that. Open <code>irb</code>:</p>

<pre lang="ruby">
>> class Thing
?> end
>> Thing.attr_accessor :name
NoMethodError: private method 'attr_accessor' called for Thing:Class
</pre>


<p>Oh. So much for that, then. But, knowing of the existence of the send method, I thought I&#8217;d try that.</p>

<pre lang="ruby">
Thing.send(:attr_accessor, :name)
=> nil
</pre>


<p>For the non-<code>irb</code> user, that <code>nil</code> that was returned, and the fact that no error message was returned, indicated that our experiment worked. Now <code>Thing</code>&#8217;s have a name attribute.</p>

<pre lang="ruby">
>> t = Thing.new
>> t.name = "Larry"
=> "Larry"
>> t.name
=> "Larry"
</pre>


<p>What&#8217;s interesting about all this is that <code>attr_accessor</code> is a private method on <code>Class</code>. Yet we just called it.</p>

<p><code>send</code> is often introduced as a way to show how everything is an object and that you can do exciting things like <code>1.send(:+, 1)</code> and get <code>2</code> as the result. No one usually mentions that it can be used to call private or protected methods from outside a given class.</p>

<p>To make it clear what you could do here:</p>

<pre lang="ruby">
>> class Thing
?>    def hello
?>     puts "Hello, world!"
?>   end
?>   private
?>     def private_hello
?>       puts "Hello, privately."
?>     end
?> end
>> t = Thing.new
>> t.hello
Hello, world!
=> nil
>> t.private_hello
NoMethodError: private method 'private_hello' called for ...
>> t.send(:private_hello)
Hello, privately.
=> nil
</pre>


<p>So, yes. You can do this, if you so choose. Please use your powers for good, and not for evil.</p>

<p>Now <em>why</em> this works, I can&#8217;t yet say, though I&#8217;m interested in learning, if there is a reason. Evidently there <a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/7404">may have been some debate</a> as to whether ruby 1.9 would still have this behavior, but as of this writing it does.</p>

<p>Note: I did only a brief search, and it seems <a href="http://www.google.com/search?client=safari&rls=en-us&q=ruby+send+method&ie=UTF-8&oe=UTF-8">this functionality is not unknown</a>, though it still seems somewhat odd to me that such an easy way to sidestep the private/protected designation of methods exists.</p>
